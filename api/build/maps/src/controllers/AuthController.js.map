{"version":3,"sources":["src/controllers/AuthController.ts"],"names":[],"mappings":"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","file":"../../../src/controllers/AuthController.js","sourcesContent":["import {Response} from 'express';\r\nimport {\r\n  Body, Delete, Post, JsonController, Req, HttpError, UseBefore, BodyParam, ForbiddenError,\r\n  InternalServerError, BadRequestError, OnUndefined, Res\r\n} from 'routing-controllers';\r\nimport {json as bodyParserJson} from 'body-parser';\r\nimport passportLoginMiddleware from '../security/passportLoginMiddleware';\r\nimport emailService from '../services/EmailService';\r\nimport {IUser} from '../../../shared/models/IUser';\r\nimport {IUserModel, User} from '../models/User';\r\nimport {JwtUtils} from '../security/JwtUtils';\r\nimport * as errorCodes from '../config/errorCodes';\r\nimport {Course} from '../models/Course';\r\nimport config from '../config/main';\r\n\r\n@JsonController('/auth')\r\nexport class AuthController {\r\n\r\n  /**\r\n   * @api {post} /api/auth/login Login user by responding with a httpOnly JWT cookie and the user's IUserModel data.\r\n   * @apiName PostAuthLogin\r\n   * @apiGroup Auth\r\n   *\r\n   * @apiParam {Request} request Login request (with email and password).\r\n   *\r\n   * @apiSuccess {IUserModel} user Authenticated user.\r\n   *\r\n   * @apiSuccessExample {json} Success-Response:\r\n   *     {\r\n   *         \"user\": {\r\n   *             \"_id\": \"5a037e6a60f72236d8e7c813\",\r\n   *             \"updatedAt\": \"2018-01-08T19:24:26.522Z\",\r\n   *             \"createdAt\": \"2017-11-08T22:00:10.897Z\",\r\n   *             \"email\": \"admin@test.local\",\r\n   *             \"__v\": 0,\r\n   *             \"isActive\": true,\r\n   *             \"lastVisitedCourses\": [],\r\n   *             \"role\": \"admin\",\r\n   *             \"profile\": {\r\n   *                 \"firstName\": \"Dago\",\r\n   *                 \"lastName\": \"Adminman\",\r\n   *                 \"picture\": {}\r\n   *             },\r\n   *             \"id\": \"5a037e6a60f72236d8e7c813\"\r\n   *         }\r\n   *     }\r\n   */\r\n  @Post('/login')\r\n  @UseBefore(bodyParserJson(), passportLoginMiddleware) // We need body-parser for passport to find the credentials\r\n  postLogin(@Req() request: any, @Res() response: Response) {\r\n    const user: IUserModel = request.user;\r\n    response.cookie('token', JwtUtils.generateToken(user), {\r\n      httpOnly: true,\r\n      sameSite: true,\r\n      // secure: true, // TODO Maybe make this configurable?\r\n    });\r\n    response.json({\r\n      user: user.toObject()\r\n    });\r\n    return response;\r\n  }\r\n\r\n  /**\r\n   * @api {delete} /api/auth/logout Logout user by clearing the httpOnly token cookie.\r\n   * @apiName AuthLogout\r\n   * @apiGroup Auth\r\n   *\r\n   * @apiSuccessExample {json} Success-Response:\r\n   *      {}\r\n   */\r\n  @Delete('/logout')\r\n  logout(@Res() response: Response) {\r\n    response.clearCookie('token');\r\n    response.json({});\r\n    return response;\r\n  }\r\n\r\n  /**\r\n   * @api {post} /api/auth/register Register user\r\n   * @apiName PostAuthRegister\r\n   * @apiGroup Auth\r\n   *\r\n   * @apiParam {IUser} user New user to be registered.\r\n   *\r\n   * @apiError BadRequestError That matriculation number is already in use\r\n   * @apiError BadRequestError That email address is already in use\r\n   * @apiError BadRequestError You can only sign up as student or teacher\r\n   * @apiError BadRequestError You are not allowed to register as teacher\r\n   * @apiError InternalServerError Could not send E-Mail\r\n   */\r\n  @Post('/register')\r\n  @OnUndefined(204)\r\n  async postRegister(@Body() user: IUser) {\r\n    const existingUser = await User.findOne({$or: [{email: user.email}, {uid: user.uid}]});\r\n    // If user is not unique, return error\r\n    if (existingUser) {\r\n      if (user.role === 'student' && existingUser.uid === user.uid) {\r\n        throw new BadRequestError(errorCodes.errorCodes.duplicateUid.code);\r\n      }\r\n      if (existingUser.email === user.email) {\r\n        throw new BadRequestError(errorCodes.errorCodes.mail.duplicate.code);\r\n      }\r\n    }\r\n    if (user.role !== 'teacher' && user.role !== 'student') {\r\n      throw new BadRequestError('You can only sign up as student or teacher');\r\n    }\r\n    if (user.role === 'teacher' && (typeof user.email !== 'string' || !user.email.match(config.teacherMailRegex))) {\r\n      throw new BadRequestError(errorCodes.errorCodes.mail.noTeacher.code);\r\n    }\r\n    const newUser = new User(user);\r\n    const savedUser = await newUser.save();\r\n    // User can now match a whitelist.\r\n    await this.addWhitelistedUserToCourses(savedUser);\r\n    try {\r\n      emailService.sendActivation(savedUser);\r\n    } catch (err) {\r\n      throw new InternalServerError(errorCodes.errorCodes.mail.notSend.code);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @api {post} /api/auth/activate Activate user\r\n   * @apiName PostAuthActivate\r\n   * @apiGroup Auth\r\n   *\r\n   * @apiParam {string} authenticationToken Authentication token.\r\n   *\r\n   * @apiSuccess {Boolean} success Confirmation of activation.\r\n   *\r\n   * @apiSuccessExample {json} Success-Response:\r\n   *     {\r\n   *         \"success\": true\r\n   *     }\r\n   *\r\n   * @apiError HttpError 422 - could not activate user\r\n   */\r\n  // TODO If activate user and is in playlist add to course.\r\n  @Post('/activate')\r\n  postActivation(@BodyParam('authenticationToken') authenticationToken: string) {\r\n    return User.findOne({authenticationToken: authenticationToken})\r\n      .then((existingUser) => {\r\n        if (!existingUser) {\r\n          throw new HttpError(422, 'could not activate user');\r\n        }\r\n\r\n        existingUser.authenticationToken = undefined;\r\n        existingUser.isActive = true;\r\n        return existingUser.save();\r\n      })\r\n      .then((user) => {\r\n        return {success: true};\r\n      });\r\n  }\r\n\r\n\r\n  /**\r\n   * @api {post} /api/auth/activationresend Resend Activation\r\n   * @apiName ActivationResend\r\n   * @apiGroup Auth\r\n   *\r\n   * @apiParam {string} lastname lastname of user which activation should be resend.\r\n   * @apiParam {string} uid matriculation number of user which activation should be resend.\r\n   * @apiParam {string} email email the new activation should be sent to.\r\n   *\r\n   * @apiError (BadRequestError) 400 User was not found.\r\n   * @apiError (BadRequestError) 400 That email address is already in use\r\n   * @apiError (BadRequestError) 400 User is already activated.\r\n   * @apiError (HttpError) 503 You can only resend the activation every X minutes. Your next chance is in\r\n   * time left till next try in 'try-after' header in seconds\r\n   * @apiError (InternalServerError) Could not send E-Mail\r\n   */\r\n  @Post('/activationresend')\r\n  @OnUndefined(204)\r\n  async activationResend (@BodyParam('lastname') lastname: string,\r\n                                      @BodyParam('uid') uid: string,\r\n                                      @BodyParam('email') email: string,\r\n                                      @Res() response: Response) {\r\n        const user = await User.findOne({'profile.lastName': lastname, uid: uid, role: 'student'});\r\n\r\n        if (!user) {\r\n          throw new BadRequestError(errorCodes.errorCodes.user.userNotFound.code);\r\n        }\r\n\r\n        if (user.isActive) {\r\n          throw new BadRequestError(errorCodes.errorCodes.user.userAlreadyActive.code);\r\n        }\r\n\r\n        const timeSinceUpdate: number = (Date.now() - user.updatedAt.getTime() ) / 60000;\r\n        if (timeSinceUpdate < Number(config.timeTilNextActivationResendMin)) {\r\n          const retryAfter: number = (Number(config.timeTilNextActivationResendMin) - timeSinceUpdate) * 60;\r\n          response.set('retry-after', retryAfter.toString());\r\n          throw new HttpError(503, errorCodes.errorCodes.user.retryAfter.code);\r\n        }\r\n\r\n        const existingUser = await User.findOne({email: email});\r\n        if (existingUser && existingUser.uid !== uid) {\r\n          throw new BadRequestError(errorCodes.errorCodes.mail.duplicate.code);\r\n        }\r\n\r\n        user.authenticationToken = undefined;\r\n        user.email = email;\r\n        const savedUser = await user.save();\r\n\r\n        try {\r\n          await emailService.resendActivation(savedUser);\r\n        } catch (err) {\r\n          throw new InternalServerError(err.toString());\r\n        }\r\n  }\r\n\r\n  /**\r\n   * @api {post} /api/auth/reset Reset password\r\n   * @apiName PostAuthReset\r\n   * @apiGroup Auth\r\n   *\r\n   * @apiParam {string} resetPasswordToken Authentication token.\r\n   * @apiParam {string} newPassword New password.\r\n   *\r\n   * @apiSuccess {Boolean} success Confirmation of reset.\r\n   *\r\n   * @apiSuccessExample {json} Success-Response:\r\n   *     {\r\n   *         \"success\": true\r\n   *     }\r\n   *\r\n   * @apiError HttpError 422 - could not reset users password\r\n   * @apiError ForbiddenError your reset password token is expired\r\n   */\r\n  @Post('/reset')\r\n  postPasswordReset(@BodyParam('resetPasswordToken') resetPasswordToken: string, @BodyParam('newPassword') newPassword: string) {\r\n    return User.findOne({resetPasswordToken: resetPasswordToken})\r\n      .then((existingUser) => {\r\n        if (!existingUser) {\r\n          throw new HttpError(422, 'could not reset users password');\r\n        }\r\n        if (existingUser.resetPasswordExpires < new Date()) {\r\n          throw new ForbiddenError('your reset password token is expired');\r\n        }\r\n\r\n        existingUser.password = newPassword;\r\n        existingUser.resetPasswordToken = undefined;\r\n        existingUser.resetPasswordExpires = undefined;\r\n        existingUser.markModified('password');\r\n        return existingUser.save();\r\n      })\r\n      .then((savedUser) => {\r\n        return {success: true};\r\n      });\r\n  }\r\n\r\n  /**\r\n   * @api {post} /api/auth/requestreset Request password reset\r\n   * @apiName PostAuthRequestReset\r\n   * @apiGroup Auth\r\n   *\r\n   * @apiParam {string} email Email to notify.\r\n   *\r\n   * @apiSuccess {Boolean} success Confirmation of email transmission.\r\n   *\r\n   * @apiSuccessExample {json} Success-Response:\r\n   *     {\r\n   *         \"success\": true\r\n   *     }\r\n   *\r\n   * @apiError HttpError 422 - could not reset users password\r\n   * @apiError InternalServerError Could not send E-Mail\r\n   */\r\n  @Post('/requestreset')\r\n  postRequestPasswordReset(@BodyParam('email') email: string) {\r\n    return User.findOne({email: email})\r\n      .then((existingUser) => {\r\n        if (!existingUser) {\r\n          throw new HttpError(422, 'could not reset users password');\r\n        }\r\n\r\n        const expires = new Date();\r\n        expires.setTime((new Date()).getTime()\r\n          // Add 24h\r\n          + (24 * 60 * 60 * 1000));\r\n\r\n        existingUser.resetPasswordExpires = expires;\r\n        return existingUser.save();\r\n      })\r\n      .then((user) => {\r\n        return emailService.sendPasswordReset(user);\r\n      })\r\n      .then(() => {\r\n        return {success: true};\r\n      })\r\n      .catch((err) => {\r\n        throw new InternalServerError('Could not send E-Mail');\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Add new user to all whitelisted courses in example after registration.\r\n   * @param {IUser} user\r\n   * @returns {Promise<void>}\r\n   */\r\n  private async addWhitelistedUserToCourses(user: IUser) {\r\n    const courses = await Course.find(\r\n      {enrollType: 'whitelist'}).populate('whitelist');\r\n\r\n    await Promise.all(courses.map(async (course) => {\r\n      const userUidIsRegisteredInWhitelist = course.whitelist.findIndex(w => w.uid === user.uid) >= 0;\r\n      const userIsntAlreadyStudentOfCourse = course.students.findIndex(u => u._id === user._id) < 0;\r\n      if (userUidIsRegisteredInWhitelist && userIsntAlreadyStudentOfCourse) {\r\n        course.students.push(user);\r\n        await course.save();\r\n      }\r\n    }));\r\n  }\r\n}\r\n"]}